<!DOCTYPE html>
<html>

<head>
    <style>
        html,
        body {
            overflow: hidden;
            font-family: sans-serif;
            background-color: #d4d4d4
        }

        body {
            margin: 0
        }

        svg {
            background: #eee;
        }

        .sphere {
            fill: #fff;
        }

        .land {
            fill: #000;
        }

        .selectLegend {
            fill-opacity: .4;
        }

        .selectLegendText {
            fill: gray;
        }

        .hiddenBox {
            display: none;
        }

        .mainSVG {
            background-color: #212133;
        }

        /* Spinner classes/keyframes etc... */
        .boundary {
            fill: none;
            stroke: #fff;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .container {
            position: fixed;
            top: 50%;
            left: 50%;
            margin-top: -32px;
            margin-left: -32px;
        }

        .lds-ellipsis {
            display: inline-block;
            position: relative;
            width: 64px;
            height: 64px;
        }

        .lds-ellipsis div {
            position: absolute;
            top: 27px;
            width: 11px;
            height: 11px;
            border-radius: 50%;
            background: #8888ff;
            animation-timing-function: cubic-bezier(0, 1, 1, 0);
        }

        .lds-ellipsis div:nth-child(1) {
            left: 6px;
            animation: lds-ellipsis1 0.6s infinite;
        }

        .lds-ellipsis div:nth-child(2) {
            left: 6px;
            animation: lds-ellipsis2 0.6s infinite;
        }

        .lds-ellipsis div:nth-child(3) {
            left: 26px;
            animation: lds-ellipsis2 0.6s infinite;
        }

        .lds-ellipsis div:nth-child(4) {
            left: 45px;
            animation: lds-ellipsis3 0.6s infinite;
        }

        @keyframes lds-ellipsis1 {
            0% {
                transform: scale(0);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes lds-ellipsis3 {
            0% {
                transform: scale(1);
            }

            100% {
                transform: scale(0);
            }
        }

        @keyframes lds-ellipsis2 {
            0% {
                transform: translate(0, 0);
            }

            100% {
                transform: translate(19px, 0);
            }
        }
    </style>

    <script src="../lib/d3.v5.min.js"></script>
    <script src="../lib/topojson.v2.min.js"></script>
</head>

<body>
    <script>
        (async () => {

            const width = 1600;
            const height = 1080;
            let filterColors = [];

            // Color to use for the place marks
            const colorPalette = [
                'rgb(31, 120, 180)',
                'rgb(51, 160, 44)',
                'rgb(102, 0, 102)',
                'rgb(227, 26, 28)',
                'rgb(12, 122, 91)',
                'rgb(255, 127, 0)',
                'rgb(0, 0, 204)',
                'rgb(106, 61, 154)',
                'rgb(153, 204, 0)',
                'rgb(177, 89, 40)',
                'rgb(153, 0, 59)',
                'rgb((179, 71, 71)'
            ];

            const zoom = d3.zoom()
                .scaleExtent([1, 100])
                .on('zoom', zoomed);

            // Build the div to contain the map and legend
            const mainDiv = d3.select('body').append('div')
                .style('width', width + 'px')
                .style('height', '1128px')
                .style('position', 'relative')
                .style('top', '50%')
                .style('left', '50%')
                .style('transform', 'translate(-50%, 0)')
                .style('margin-top', '50px')
                .style('margin-bottom', '50px')
                .style('border-opacity', 0)
                .style('border', 'solid 1px black')
                .style('background-color', 'white')
                .style('box-shadow', '5px 5px 10px #000000');

            // Spinner to show while the points are being plotted, mainly created in CSS above
            const spinner_element = mainDiv.append('div')
                .attr('class', 'container')
                .attr('id', 'spinner_container')
                .append('div')
                .attr('class', 'lds-ellipsis')
                .attr('id', 'spinner');
            spinner_element.append('div');
            spinner_element.append('div');
            spinner_element.append('div');
            spinner_element.append('div');

            // Div to contain title
            const title = mainDiv.append('svg')
                .attr('width', width)
                .attr('height', 45)
                .style('background-color', 'white')
                .style('position', 'relative')
                .append('text')
                .style('height', '50px')
                .style('font-size', '24pt')
                .attr('transform', 'translate(580,35)')
                .text('2014 California Earthquake');

            // Primary SVG element for d3
            const svg = mainDiv.append('svg')
                .attr('width', width)
                .attr('height', height)
                .attr('class', 'mainSVG');

            // Group for the data points
            const boxes = svg.append('g');
            const g = boxes.append('g');

            // Scale for the size of the data points
            const boxSize = d3.scaleLinear()
                .domain([-5, 5])
                .range([2, 10]);

            // Scale for the opacity of the data points
            const opacity = d3.scaleLinear()
                .domain([-5, 5])
                .range([.2, .8]);

            // Activate the zoom capability
            svg.call(zoom);

            // Load the data using the loadData() function below
            data = await loadData();
            places = data[0].map(p => ({
                ...p,
                category: titleCase(String(p.category).split('_').join(' '))
            }))
            usTopoData = data[1];
            countyData = data[2];
            states_ids_abbrevs = data[3];

            // Pull out the distinct event types
            const emergencies = [...new Set(places.map(p => p.category))].map(e => ({
                name: e,
                group: boxes.append('g')
            }));

            // Originally this keyed off of the states found in the data set, that is not
            // available in the current data set, so it's hard-coded
            activeStates = ['California']
            activeStates = activeStates.map(as => ({
                'id': states_ids_abbrevs.find(sia => sia.Name === as).FIPS_Code,
                'name': as
            }));
            // Get the list of counties for each state in the data set. This is the list of counties to draw on the map
            activeCounties = countyData.filter(cd => activeStates.some(as => as.name === cd.State));

            // Remove the geometry structures for states and counties not being mapped
            usTopoData.objects.counties.geometries = usTopoData.objects.counties.geometries.filter(g =>
                activeCounties.some(ac => Number(ac.Id) === g.id));
            usTopoData.objects.states.geometries = usTopoData.objects.states.geometries.filter(g =>
                activeStates.some(as => Number(as.id) === g.id));

            // Projection scale used to convert geo coords to x,y coords in d3
            var projection = d3.geoAlbersUsa()
                .scale(5300)
                .translate([2500, height / 1.75]);

            var path = d3.geoPath()
                .projection(projection);

            // Draw the counties
            g.selectAll('path')
                .data(
                    topojson.feature(
                        usTopoData,
                        usTopoData.objects.counties
                    ).features
                )
                .enter()
                .append('path')
                .attr('fill', d => {
                    return activeCounties.some(ac => Number(ac.Id) === d.id) ? '#4e4e4e' : '#d3d3d3'
                })
                .attr('stroke', 'darkgray')
                .attr('stroke-width', .25)
                .attr('stroke-linejoin', 'round')
                .attr('d', path);


            // Draw the states
            g.append('path')
                .datum(
                    topojson.mesh(
                        usTopoData,
                        usTopoData.objects.states,
                        (a, b) => a !== b
                    )
                )
                .attr('fill', 'none')
                .attr('stroke', 'white')
                .attr('stroke-width', 1)
                .attr('stroke-linejoin', 'round')
                .attr('d', path);

            // Plot the data points
            places.forEach(place => {
                drawMarker(place);
            });

            // Create the legend and legend text
            legend = mainDiv
                .append('svg')
                .attr('width', 420)
                .style('position', 'absolute')
                .style('top', '0')
                .style('right', '0')
                .attr('height', emergencies.length * 33)
                .style('padding', '10px')
                .style('margin-top', '60px')
                .style('margin-right', '10px')
                .style('border', 'solid 2px black')
                .style('background-color', '#d4d4d4')
                .append('g');

            legend.selectAll('rect')
                .data(colorPalette)
                .enter()
                .append('rect')
                .attr('fill', d => d)
                .attr('width', 30)
                .attr('height', 30)
                .attr('x', d => 0)
                .attr('y', (d, idx) => 33 * idx)
                .style('cursor', 'pointer')
                .on('click', filterColor)
                .on('mouseover', mouseHover)
                .on('mouseout', mouseOut);

            legendText = legend.append('g');
            legendText.selectAll('text')
                .data(emergencies)
                .enter()
                .append('text')
                .attr('x', 35)
                .attr('y', (d, idx) => 33 * idx + 10)
                .attr('transform', 'translate(10,10)')
                .attr('fill', 'black')
                .text(d => d.name);

            // Hide the spinner
            spinner.style.visibility = 'collapse';

            // Function to load the data asynchronously
            async function loadData() {
                const p = await d3.tsv('./california_labeled_formatted_tweets_split0.txt');
                const t = await d3.json('./us.json');
                const c = await d3.csv('./us_county_data.csv');
                const s = await d3.csv('./states_fips_data.csv');

                return [p, t, c, s]
            }

            // Function to draw a marker on the map. The color is based on event type. The size and opacity
            // of the marker are based on the sentiment value
            function drawMarker(data) {
                event = emergencies.find(e => e.name === data.category);
                event.group
                    .append('rect')
                    .attr('class', 'boundingBox')
                    .attr('rx', '5px')
                    .attr('ry', '5px')
                    .attr('x', projection([Number(data.long), Number(data.lat)])[0])
                    .attr('y', projection([Number(data.long), Number(data.lat)])[1])
                    // sentiment
                    .attr('width', boxSize(data.sentiment+20))
                    .attr('height', (d, a, b) => b[a].width.baseVal.value)
                    .style('fill', colorPalette[emergencies.indexOf(event)])
                    .attr('fill-opacity', opacity(data.sentiment+20))
            }

            // Function to filter the colors of markers to display and change the legend text to note disabled or not.
            function filterColor(e, a, b) {
                legendRect = b[a];
                if (filterColors.includes(e)) {
                    filterColors = filterColors.filter(c => c !== e);
                    legendRect.removeAttribute('class');
                    boxes.selectAll('rect.hiddenBox[style*="fill: ' + e + '"]')
                        .attr('class', 'boundingBox');
                    legendText.selectAll('text:nth-child(' + (a + 1) + ')')
                        .attr('class', '')
                } else {
                    filterColors.push(e);
                    legendRect.setAttribute('class', 'selectLegend');
                    boxes.selectAll('rect.boundingBox[style*="fill: ' + e + '"]')
                        .attr('class', 'hiddenBox');
                    legendText.selectAll('text:nth-child(' + (a + 1) + ')')
                        .attr('class', 'selectLegendText')
                }
            }

            // Function to highlight disabled legend rects on mouse over
            function mouseHover(e, a, b) {
                legendRect = b[a];
                legendRect.setAttribute('class', '');
            }

            // Function to set the class correctly for the legend rects on mouse out
            function mouseOut(e, a, b) {
                legendRect = b[a];
                legendRect.setAttribute('class', filterColors.includes(e) ? 'selectLegend' : '');
            }

            // Function to perform zoom function on scroll wheel
            function zoomed() {
                boxes.attr("transform", d3.event.transform)
            }

            // Function to convert a string to titlecase (first letter of each word capital)
            function titleCase(str) {
                str = str.toLowerCase().split(' ');
                for (var i = 0; i < str.length; i++) {
                    str[i] = str[i].charAt(0).toUpperCase() + str[i].slice(1);
                }
                return str.join(' ');
            }
        })();
    </script>
</body>

</html>
